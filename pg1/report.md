# System Calls of Copying

by [Yuchen Ying](mailto:yegle@uga.edu) and [Yue Yin](mailto:yueyin@uga.edu)

## Running Program and Output

Here's an example of copying file from (`-f`) `/tmp/tmp/.1f9OCezipI` to (`-t`) `/tmp/tmp.6Wnc80Pke9` using mode (`-m`) 1.

    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/usr/lib/jvm/jdk1.7.0_06/jre/lib" Copy -m 1 -f /tmp/tmp.1f9OCezipI -t /tmp/tmp.6Wnc80Pke9

The mode option (`-m`) has three possible value:

 1. Copy using `java.io`
 2. Copy using `java.nio`
 3. Copy using `JNI`

The running result is:

    Copied 46 bytes, from /tmp/tmp.1f9OCezipI to /tmp/tmp.6Wnc80Pke9
    Time used in copy operation is 50666735 nano seconds

## Performance Test

### Copy Performance

The performance timing codes was included in our program. Copy performance test using our own code and using `time` command is listed below.

From the result, we can know that `java.nio` has the best performance.

We also tested our program on Mac OSX Mountain Lion (10.8.1) with Oracle's latest `JDK 7u6` for Mac OSX. The result shows that `JNI` has the best performance. We think the performance difference between `JDK` for Linux and `JDK` for MacOSX is because Oracle hasn't fully optimized it's Mac version.

    $ make test  

    # TEST java.io
    dd if=/dev/urandom of=/tmp/tmp.RXzOgAnWSd bs=1k count=10240
    10240+0 records in  
    10240+0 records out  
    10485760 bytes (10 MB) copied, 1.34969 s, 7.8 MB/s  
    TEST `java.io`  
    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 1 -f /tmp/tmp.RXzOgAnWSd -t /tmp/tmp.Qki5DeED0W
    Copied 10485760 bytes, from /tmp/tmp.RXzOgAnWSd to /tmp/tmp.Qki5DeED0W  
    Time used in copy operation is 52175684 nano seconds  
    
    # TEST java.nio
    dd if=/dev/urandom of=/tmp/tmp.RXzOgAnWSd bs=1k count=10240
    10240+0 records in  
    10240+0 records out  
    10485760 bytes (10 MB) copied, 1.36501 s, 7.7 MB/s  
    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 2 -f /tmp/tmp.RXzOgAnWSd -t /tmp/tmp.Qki5DeED0W
    Copied 10485760 bytes, from /tmp/tmp.RXzOgAnWSd to /tmp/tmp.Qki5DeED0W  
    Time used in copy operation is 18634960 nano seconds
    
    # TEST JNI
    dd if=/dev/urandom of=/tmp/tmp.RXzOgAnWSd bs=1k count=10240
    10240+0 records in  
    10240+0 records out  
    10485760 bytes (10 MB) copied, 1.36217 s, 7.7 MB/s  
    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 3 -f /tmp/tmp.RXzOgAnWSd -t /tmp/tmp.Qki5DeED0W
    Copied 10485760 bytes, from /tmp/tmp.RXzOgAnWSd to /tmp/tmp.Qki5DeED0W  
    Time used in copy operation is 25553641 nano seconds

We also tested our program with the `time` command. The result as below:

    # TEST java.io
    $ time LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 1 -f /tmp/tmp.os4sxT7X5M -t /tmp/tmp.x2rXEmRknx
    Copied 104857600 bytes, from /tmp/tmp.os4sxT7X5M to /tmp/tmp.x2rXEmRknx
    Time used in copy operation is 547318247 nano seconds
    
    real    0m0.751s
    user    0m0.160s
    sys 0m0.553s

    # TEST java.nio
    $ time LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 2 -f /tmp/tmp.os4sxT7X5M -t /tmp/tmp.x2rXEmRknx
    Copied 104857600 bytes, from /tmp/tmp.os4sxT7X5M to /tmp/tmp.x2rXEmRknx
    Time used in copy operation is 175290550 nano seconds

    real    0m0.295s
    user    0m0.073s
    sys 0m0.240s

    # TEST JNI
    $ time LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 3 -f /tmp/tmp.os4sxT7X5M -t /tmp/tmp.x2rXEmRknx
    Copied 104857600 bytes, from /tmp/tmp.os4sxT7X5M to /tmp/tmp.x2rXEmRknx
    Time used in copy operation is 265181910 nano seconds

    real    0m0.387s
    user    0m0.080s
    sys 0m0.325s

### Memory Usage

It's hard to capture the memory usage of our program because the copy process usually takes few seconds.

At the end we uses `top` command's `-d` option, together with `-b` option, to get our memory usage.

Result:

    $ top -u ying -b -d 0.1 |grep java
    10152 ying      20   0 35.5g  30m 9124 S    99  0.0   0:00.74 java

## `strace` Log Analysis

By running our program under `strace`, we can analyse the system calls used by our program.

    LD_LIBRARY_PATH=. strace -ff -o ~/test1-strace.log java -classpath ".:../lib/commons-cli-1.2.jar:/usr/lib/jvm/jdk1.7.0_06/jre/lib" Copy -m 3 -f /tmp/tmp.1f9OCezipI -t /tmp/tmp.6Wnc80Pke9

Here is a piece of record that we care about. This is the output generated by `strace` when copying file using `JNI`.

    open("/tmp/tmp.qeU1c8opRC", O_RDONLY)   = 6
    open("/tmp/tmp.fr2IDkFONz", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 7
    read(6, "1\n", 4096)                    = 2
    write(7, "1\n", 2)                      = 2
    read(6, "", 4096)                       = 0
    close(7)                                = 0
    close(6)                                = 0

There are some small differences of the system calls used by the 3 APIs (`java.io`, `java.nio.*`, `JNI`). Notable differences are listed below:

 1. `java.io` will do a `stat()` after `open()` the source and destination files. We guess this is caused by `JVM` itself.
 2. Before `open()` the source and destination files, `java.nio` will use `stat()` to determine if the destination file already exists. If so, the `unlink()` system call is invoked to delete it first. This should be caused by the `REPLACE_EXISTING` flag we passed in the `Files.copy` method.

By getting familar with these file system calls, we can figure out the main process of copying files:

 1. Precheck the source file and destination file using `stat()` or `lstat()`, if the destination file exists, use `unlink()` to delete it _(optional)_
 2. Open the source file using `open()`, get the returned file descriptor
 3. Open the destination file using `open()`. If the file doesn't exists, the `O_CREAT` flag passed to `open()` system call will create the file automatically.
 4. Call `read()` on the source file's descriptor and call `write()` on the destination file's descriptor. Loop until the file is completely copied.
 5. Call `close()` on both the source file and destination file's descriptor.

## Related System Calls for File Management

### `open()`

Open or create a file for reading or writing

### `read()`

Read input

### `write()`

Write output

### `close()`

Delete a descriptor

### `stat()` and `lstat()`

Get file status

### `unlink()`

Remove directory entry

