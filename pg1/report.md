# System Calls of Copying

by [Yuchen Ying](mailto:yegle@uga.edu) and [Yue Yin](mailto:yueyin@uga.edu)

## Running Program and Output

Here's an example of copying file from (`-f`) `/tmp/tmp/.1f9OCezipI` to (`-t`) `/tmp/tmp.6Wnc80Pke9` using mode (`-m`) 1.

    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/usr/lib/jvm/jdk1.7.0_06/jre/lib" Copy -m 1 -f /tmp/tmp.1f9OCezipI -t /tmp/tmp.6Wnc80Pke9

The mode option (`-m`) has three possible value:

 1. Copy using `java.io`
 2. Copy using `java.nio`
 3. Copy using `JNI`

The running result is:

    Copied 46 bytes, from /tmp/tmp.1f9OCezipI to /tmp/tmp.6Wnc80Pke9
    Time used in copy operation is 50666735 nano seconds

## Performance Test

### Copy Performance

The performance timing codes was included in our program. Copy performance test using our own code and using `time` command is listed below.

From the result, we can know that `java.nio` has the best performance.

We also tested our program on Mac OSX Mountain Lion (10.8.1) with Oracle's latest `JDK 7u6` for Mac OSX. The result shows that `JNI` has the best performance. We think the performance difference between `JDK` for Linux and `JDK` for MacOSX is because Oracle hasn't fully optimized it's Mac version.

    $ make test  

    # TEST java.io
    dd if=/dev/urandom of=/tmp/tmp.RXzOgAnWSd bs=1k count=10240
    10240+0 records in  
    10240+0 records out  
    10485760 bytes (10 MB) copied, 1.34969 s, 7.8 MB/s  
    TEST `java.io`  
    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 1 -f /tmp/tmp.RXzOgAnWSd -t /tmp/tmp.Qki5DeED0W
    Copied 10485760 bytes, from /tmp/tmp.RXzOgAnWSd to /tmp/tmp.Qki5DeED0W  
    Time used in copy operation is 52175684 nano seconds  
    
    # TEST java.nio
    dd if=/dev/urandom of=/tmp/tmp.RXzOgAnWSd bs=1k count=10240
    10240+0 records in  
    10240+0 records out  
    10485760 bytes (10 MB) copied, 1.36501 s, 7.7 MB/s  
    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 2 -f /tmp/tmp.RXzOgAnWSd -t /tmp/tmp.Qki5DeED0W
    Copied 10485760 bytes, from /tmp/tmp.RXzOgAnWSd to /tmp/tmp.Qki5DeED0W  
    Time used in copy operation is 18634960 nano seconds
    
    # TEST JNI
    dd if=/dev/urandom of=/tmp/tmp.RXzOgAnWSd bs=1k count=10240
    10240+0 records in  
    10240+0 records out  
    10485760 bytes (10 MB) copied, 1.36217 s, 7.7 MB/s  
    LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 3 -f /tmp/tmp.RXzOgAnWSd -t /tmp/tmp.Qki5DeED0W
    Copied 10485760 bytes, from /tmp/tmp.RXzOgAnWSd to /tmp/tmp.Qki5DeED0W  
    Time used in copy operation is 25553641 nano seconds

We also tested our program with the `time` command. The result as below:

    # TEST java.io
    $ time LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 1 -f /tmp/tmp.os4sxT7X5M -t /tmp/tmp.x2rXEmRknx
    Copied 104857600 bytes, from /tmp/tmp.os4sxT7X5M to /tmp/tmp.x2rXEmRknx
    Time used in copy operation is 547318247 nano seconds
    
    real    0m0.751s
    user    0m0.160s
    sys 0m0.553s

    # TEST java.nio
    $ time LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 2 -f /tmp/tmp.os4sxT7X5M -t /tmp/tmp.x2rXEmRknx
    Copied 104857600 bytes, from /tmp/tmp.os4sxT7X5M to /tmp/tmp.x2rXEmRknx
    Time used in copy operation is 175290550 nano seconds

    real    0m0.295s
    user    0m0.073s
    sys 0m0.240s

    # TEST JNI
    $ time LD_LIBRARY_PATH=. java -classpath ".:../lib/commons-cli-1.2.jar:/home/grads/ying/.gentoo/etc/java-config-2/current-system-vm/jre/lib" Copy -m 3 -f /tmp/tmp.os4sxT7X5M -t /tmp/tmp.x2rXEmRknx
    Copied 104857600 bytes, from /tmp/tmp.os4sxT7X5M to /tmp/tmp.x2rXEmRknx
    Time used in copy operation is 265181910 nano seconds

    real    0m0.387s
    user    0m0.080s
    sys 0m0.325s

### Memory Usage

It's hard to capture the memory usage of our program because the copy process usually takes few seconds.

At the end we uses `top` command's `-d` option, together with `-b` option, to get our memory usage.

Result:

    $ top -u ying -b -d 0.1 |grep java
    10152 ying      20   0 35.5g  30m 9124 S    99  0.0   0:00.74 java

## `strace` Log Analysis

By running our program under `strace`, we can analyse the system calls used by our program.

    LD_LIBRARY_PATH=. strace -ff -o ~/test1-strace.log java -classpath ".:../lib/commons-cli-1.2.jar:/usr/lib/jvm/jdk1.7.0_06/jre/lib" Copy -m 3 -f /tmp/tmp.1f9OCezipI -t /tmp/tmp.6Wnc80Pke9

Here is a piece of record that we care about. This is the output generated by `strace` when copying file using `JNI`.

    open("/tmp/tmp.qeU1c8opRC", O_RDONLY)   = 6
    open("/tmp/tmp.fr2IDkFONz", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 7
    read(6, "1\n", 4096)                    = 2
    write(7, "1\n", 2)                      = 2
    read(6, "", 4096)                       = 0
    close(7)                                = 0
    close(6)                                = 0

There are some small differences of the system calls used by the 3 APIs (`java.io`, `java.nio.*`, `JNI`). Notable differences are listed below:

 1. `java.io` will do a `stat()` after `open()` the source and destination files. We guess this is caused by `JVM` itself.
 2. Before `open()` the source and destination files, `java.nio` will use `stat()` to determine if the destination file already exists. If so, the `unlink()` system call is invoked to delete it first. This should be caused by the `REPLACE_EXISTING` flag we passed in the `Files.copy` method.

By getting familar with these file system calls, we can figure out the main process of copying files:

 1. Precheck the source file and destination file using `stat()` or `lstat()`, if the destination file exists, use `unlink()` to delete it _(optional)_
 2. Open the source file using `open()`, get the returned file descriptor
 3. Open the destination file using `open()`. If the file doesn't exists, the `O_CREAT` flag passed to `open()` system call will create the file automatically.
 4. Call `read()` on the source file's descriptor and call `write()` on the destination file's descriptor. Loop until the file is completely copied.
 5. Call `close()` on both the source file and destination file's descriptor.

## Related System Calls

### `open`

Open or create a file for reading or writing

    SYNOPSIS 
        #include <sys/types.h> 
        #include <sys/stat.h> 
        #include <fcntl.h> 
    
        int open (const char *path, int oflag); 
    
    DESCRIPTION 
        path points to a path name naming a file.  open opens a file descriptor 
        for the named file and sets the file status flags according to the value 
        of oflag. 
    
        O_RDONLY 
               Open for reading only. 
    
        O_WRONLY 
               Open for writing only. 
    
        O_RDWR Open for reading and writing. 


### `read()`

Read input

    SYNOPSIS 
        #include <unistd.h> 
        ssize_t read(int fildes, void *buf, size_t nbyte); 
    
    DESCRIPTION 
        read attempts to read nbyte bytes from the file associated with fildes 
        into the buffer pointed to by buf.  If nbyte is zero, read returns zero 
        and has no other results. 


### `write()`

Write output

    SYNOPSIS 
        #include <unistd.h> 
        ssize_t write(int fildes, const void *buf, size_t nbyte); 
    
    DESCRIPTION 
        write attempts to write nbyte bytes from the buffer pointed to by buf to 
        the file associated with fildes.  If nbyte is zero and the file is a 
        regular file, write returns zero and has no other results.  fildes is a 
        file descriptor. 


### `close()`

Delete a descriptor

    SYNOPSIS 
        #include <unistd.h> 
        int close(int fildes); 
    
    DESCRIPTION 
        close closes the file descriptor indicated by fildes. 

### `stat()` and `lstat()`

Get file status

    SYNOPSIS
        #include <sys/stat.h>
        int lstat(const char *restrict path, struct stat *restrict buf);
        int stat(const char *restrict path, struct stat *restrict buf);
    
    DESCRIPTION
        The stat() function obtains information about the file pointed to by
        path.  Read, write or execute permission of the named file is not
        required, but all directories listed in the path name leading to the file
        must be searchable.

        The lstat() function is like stat() except in the case where the named
        file is a symbolic link; lstat() returns information about the link,
        while stat() returns information about the file the link references.
        Unlike other filesystem objects, symbolic links may not have an owner,
        group, access mode, times, etc.  Instead, these attributes may be taken
        from the directory that contains the link.  In this case, the only
        attributes returned from an lstat() that refer to the symbolic link
        itself are the file type (S_IFLNK), size, blocks, and link count (always
                1).


### `unlink()`

Remove directory entry

    SYNOPSIS
        #include <unistd.h>
    
        int unlink(const char *path);
    
    DESCRIPTION
        The unlink() function removes the link named by path from its directory
        and decrements the link count of the file which was referenced by the
        link.  If that decrement reduces the link count of the file to zero, and
        no process has the file open, then all resources associated with the file
        are reclaimed.  If one or more process have the file open when the last
        link is removed, the link is removed, but the removal of the file is
        delayed until all references to it have been closed.
